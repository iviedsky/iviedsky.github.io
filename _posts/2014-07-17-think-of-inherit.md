---
layout: post
title: 面向对象的程序设计（一）——关于继承 
category : 设计思想
tagline: "Supporting tagline"
tags : [设计思想]
markdown: rdiscount
---
{% include JB/setup %}
---

##面向对象的程序设计（一）
###——关于继承
------
###一、面向对象的程序设计：

博主编写“面向对象的程序设计”系列，主要目的在于分享博主在设计过程中遇到的一些典型错误。

文章的主要内容是博主在修正这些错误的过程中进行的归纳、思考和总结的产物，包括参考的官方文档和网络资料的引用，以及楼主的一些个人总结。

博主希望这一过程不但会使自己进一步加深对软件设计的理解，而且能够和各位同行们相互学习探讨，相互进步。

<!--break-->

###二、面向对象和继承

这篇博文主要围绕“继承”这一特性展开。

但是，我们有必要回顾一下面向对象程序设计的主要特性，如下：

1、封装:隐藏了某一方法的具体执行步骤，取而代之的是通过消息传递机制传送消息给它。

2、继承:继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充

3、多态:由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。

4、抽象:抽象可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。





“封装”只依赖于类和对象的概念。

“多态”和“抽象”这两个特性则依赖于“继承”（包括实现接口和继承于基类）。用比较简单的实例来表述：



当A、B两个类继承于S时，A和B分别重写了S的一个方法。你调用这个方法的时候，就用到了“多态”这个特性。

当一段代码中，需要使用S的实例时，你代入了一个其子类A的实例，就用到了“抽象”这个特性。

正确地使用“继承”这一特性，可以很好地解决“代码复用”和“业务逻辑分化”这两个问题。但是一旦使用方法不当，后果也是很严重的。

###三、典型的错误

1、违背里氏代换原则

里氏代换原则：凡是父类实例可以出现的地方，都可以由其子类实例出现。

里氏代换原则是继承复用机制的基石。

要做到里氏代换原则，父类一定不能包含其子类不需要实现的功能。否则“子类isa父类”这一逻辑不成立。

错误的继承关系类图如下：

![违背里氏代换原则的实例](/image/think-of-inherit_01.png =400x220)

“AppStore官方支付工具”继承自“支付工具”这个类。然而，后者（父类）包含一个“支付宝支付”的方法，这个方法与前者（子类）没有任何关系。那么，在后者（父类）出现的地方，前者（子类）就不能替代后者（父类）出现了。因为“支付宝支付”这个方法可能会被调用，进而导致逻辑错误。

2、违背依赖倒置原则

依赖倒置原则：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体，具体应该依赖于抽象。

所谓高层次的模块是指被继承的模块(父类或者接口)，而低层次的模块是继承于父类或者实现了接口的类或者接口。

要做到依赖倒置原则，则父类一定不能知道子类的存在。父类中不能够出现子类的相关的任何逻辑。

以下是错误的继承关系：

![违背依赖倒置原则的实例](/image/think-of-inherit_02.png =400x220)

父类“支付工具”有一个“支付类型”的属性，为枚举类型，用于表示当前这个实例是“支付宝支付工具”的实例还是“AppStore官方支付工具”的实例，以便在支付逻辑中进行逻辑分化。

该错误造成的后果是：

a.当你关注于“支付宝支付工具”的逻辑的时候，可能会追溯到其父类“支付工具”的逻辑（这是正常的，因为子类和父类是isa的关系），而在父类中，你居然还能看到关于“AppStore官方支付工具”的逻辑。

b.如果有一天，“支付宝支付工具”这个子类不需要了被删除，父类“支付工具”中还会残留和它相关逻辑代码。如果再有一天，需求变更，新增一个“银联支付工具”类，继承自“支付工具”。“支付工具”也不得不修改，这样的修改可能还会影响到其它的子类。

3、违背开闭原则

开闭原则：对扩展开放，对修改封闭。开闭原则是面向对象设计原则的总则,是其它几项设计原则的目的。

如果继承关系使用正确——即满足里氏代换原则，又满足依赖倒置原则。那么，这样的设计才可能是满足开闭原则的设计。

以下是正确的继承关系类图：

![违背依赖倒置原则的实例](/image/think-of-inherit_03.png =800x220)

按照以上两种设计，如果需求变更导致“支付工具”的任何子类被删除，“支付工具”本身和它的其它子类均不会受到影响。同时也不会有任何与被删除的子类相关的业务逻辑残留。同理，要新增任何子类，新增的子类也不会对其父类和兄弟类造成影响。这就满足了开闭原则。发挥了面向对象设计实实在在的优势。

###四、总结

这篇博文主要阐述了面向对象的继承、抽象、多态这3个特性。

面向对象的设计想要正确地发挥“继承”的作用，就必须要遵守里氏代换原则和依赖倒置原则。

错误地使用继承关系反而会增加模块之间的耦合程度，适得其反。


该系列接下来的一篇博文，博主会和大家分享面向对象设计的另一个特性——“封装”，以及“封装”和“迪米特法则”之间的关系。

